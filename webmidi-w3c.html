<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>W3C Web MIDI events</title>
    <meta name="author" content="https://github.com/francoisgeorgy">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://cdn.rawgit.com/moment/moment/03073778/moment.js"></script>
    <style>
        html {
            font-family: sans-serif;
        }
        #clear-all {
            float: right;
            font-size: 1em;
        }
        .gray-box {
            border: 1px solid #aaa;
            background-color: #f0f0f0;
            padding: 1rem;
            margin: 1rem;
            text-align: left;
        }
        #events, #state, #inputs, #outputs {
            font-family: monospace;
            white-space: pre;
        }
        .gray {
            color: #999;
        }
    </style>
</head>
<body>

    <button id="clear-all">clear all</button>

    <h1>Web MIDI API: w3c standard API</h1>

    <h3>onStateChange: (last event first)</h3>
    <div id="state" class="gray-box"></div>
        
    <h3>onMidiMessage: (last event first)</h3>
    <div id="events" class="gray-box"></div>

    <h3>Inputs (MIDI sources):</h3>
    <div id="inputs" class="gray-box"></div>

    <h3>Outputs (MIDI targets):</h3>
    <div id="outputs" class="gray-box"></div>

    <script>

        // No ES6 fancy features, because we try to remain compatible with http://www.taktech.org/takm/WebMIDIBrowser/Web_MIDI_Browser.html

        var W3CMidi = null;  // global MIDIAccess object

        // print in reverse order
        function log(what, where) {
            var c = what.startsWith("(") ? "gray" : "";
            $(where).prepend("<span class=\"" + c + "\">[" + moment().format('HH:mm:ss.SSS') + "] " + what + "</span>\n");
        }

        function toHexString(byteArray, sep) {
            // var s = sep || '';
            // h = '';
            // for (var i=0; i<byteArray.length; i++) {
            //     h = h + ('0' + (byteArray[i] & 0xFF).toString(16)).slice(-2) + s;
            // }
            // return h.trim();
            return Array.from(byteArray, function (byte) {
                return ('0' + (byte & 0xFF).toString(16)).slice(-2);
            }).join(sep || '');
        }

        function listInputsAndOutputs() {
            console.log("listInputsAndOutputs");
            if (W3CMidi === null) return;
            $("#inputs").html("");
            $("#outputs").html("");
            var iter = W3CMidi.inputs.values();
            for (var o = iter.next(); !o.done; o = iter.next()) {
                var i = o.value;
                log(i.type + ' ' + i.state + ' ' + i.manufacturer + ' "' + i.name + '" ' + i.id, "#inputs");
            }
            var iter = W3CMidi.outputs.values();
            for (var o = iter.next(); !o.done; o = iter.next()) {
                var i = o.value;
                log(i.type + ' ' + i.state + ' ' + i.manufacturer + ' "' + i.name + '" ' + i.id, "#outputs");
            }
        }

        function setInputListeners() {
            var inputs = W3CMidi.inputs.values();
            for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
                console.log(`setInputListeners: add onMidiMessageHandler for input "${input.value.name}"`);
                input.value.onmidimessage = onMidiMessageHandler;
            }
        }

        function onMidiMessageHandler(event) {
            if (event instanceof MIDIMessageEvent) {
                var bytes = event.data;         // type is Uint8Array
                var channel = bytes[0] & 0x0F;  // MIDI channel
                var type = bytes[0] & 0xF0;     // MIDI event type
                var port = event.currentTarget;
                log(event.type + ': "' + port.name + '" ' + port.type + ' on channel ' + channel + ', type: ' + type + ', data: ' + toHexString(bytes, ' '), "#events");
            } else {
                log(event.type + ': ' + toHexString(event.data, ''), "#events");
            }
        }

        function onStateChangeHandler(event) {
            console.group("onStateChangeHandler");
            var p = event.port;
            console.log('"' + p.name + '" ' + p.type + ' ' + p.state + ' (' + p.connection + ')', event);
            log('"' + p.name + '" ' + p.type + ' ' + p.state + ' (' + p.connection + ')', "#state");
            if (p.state === "connected") {
                // Handle the connection
                if (p.type === "input") {
                    p.onmidimessage = onMidiMessageHandler;
                    log('("' + p.name + '" input listener added)', "#state");
                }
            } else if (p.state === "disconnected") {
                // Handle the disconnection
                if (p.type === "input") {
                    p.onmidimessage = null;
                    log('("' + p.name + '" input listener removed)', "#state");
                }
            } else {
                log(p.type + ' "' + p.name + '" is in an unknown state: ' + p.state , "#state");
            }
            listInputsAndOutputs();
            console.groupEnd();
        }

        $(function () {

            $('#clear-all').click(function(){
                $('#events, #state, #inputs, #outputs').html('');
            });

            if (navigator.requestMIDIAccess) {

                navigator.requestMIDIAccess({ sysex: true }).then(onMIDISuccess, onMIDIFailure);

                function onMIDISuccess(midiAccess) {
                    log("Got access to MIDI", "#state");
                    W3CMidi = midiAccess;
                    W3CMidi.onstatechange = onStateChangeHandler;
                    listInputsAndOutputs();
                    setInputListeners();
                }

                function onMIDIFailure(msg) {
                    console.warn("Failed to get MIDI access", msg);
                    log("Failed to get MIDI access. " + msg, "#state");
                }

            } else {
                log("ERROR: navigator.requestMIDIAccess not supported", "#state");
            }

        });
    </script>
</body>
</html>